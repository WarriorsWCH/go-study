

package main

import(
	"fmt"
	"unsafe"
)

func main() {
	// 小数类型/浮点型
	var price float32 = 89.12
	fmt.Println("price=",price)
	// 小数类型分类
	// 单精度float32，占用4字节，表示范围 -3.403E38 - 3.403E38
	// 双精度float64，占用8字节，表示范围 -1.798E308 - 1.798E308
	// 说明：
	// 1.浮点数在机器中存放形式的简单说明，浮点数=符号位+指位数+尾数位（浮点数都是有符号的）
	// 2.位数部分可能丢失，造成精度损失
	// 3.float64精度高于float32

	var num1 float32 = -1230.000089
	var num2 float64 = -1230.000089
	fmt.Println("num1=",num1,"num2=",num2)

	// 浮点数使用细节
	// 1.go的浮点数类型有固定的范围和长度字段，不受os的影响
	// 2.go的浮点默认类型声明为float64
	// 3.浮点型常量有两种表示方式
	// 3.1十进制表示
	var num3 = .52
	var num4 = 5.52
	fmt.Println("num3=",num3,"num4=",num4)
	// 3.2科学计数法表示
	num5 := 5.123e2
	num6 := 5.123E2
	num7 := 5.123E-2 //除以10的2次方
	fmt.Println("num5=",num5,"num6=",num6,"num7=",num7)
	// 4.通常情况下，我们应该使用float64


	// 字符类型
	// go中没有专门的字符类型，如果要存储单个字符（字母），一般使用byte来保存
	// 字符串就是一串固定长度的字符连接起来的字符序列
	// go的字符串是由单个字节连接起来的，也就是说对于传统的字符串是由字符组成的，而go的字符串不同，它是由字节组成的

	var c1 byte = 'a'
	var c2 byte = '0'
	// 直接输出对应字符的编码
	fmt.Println("c1=",c1,"c2=",c2)
	// 格式化输出对应的字符
	fmt.Printf("c1=%c c2=%c\n",c1,c2)
	// 防止溢出使用更大的int保存
	var c3 int = '美'
	fmt.Printf("c3=%c c3对应的码值=%d\n",c3,c3)

	// 说明
	// 1.如果我们保存的字符在ASCII表中，我们可以直接使用byte保存
	// 2.如果我们保存的字符值大于255，这是我们可以使用int保存
	// 3.如果我们需要按照字符输出，可以使用%c格式化输出

	// 细节
	// 1.字符是使用单引号括起来的单个字符
	// 2.go中允许使用转义字符'\'来将其后的字符转变为特殊字符型常量，var c4 char ='\n'
	// 3.go语言的字符使用UTF-8编码，如果想查询对应的UTF8码值http://www.mytju.com/classcode/tools/encode_utf8.asp
	// 英文字母1个字节，汉子3个字节
	// 4.在go中，字符的本质是一个整数，直接输出时，是该字符对应的UTF-8编码的码值
	// 5.可以直接给某个变量赋一个数字，然后格式化输出时%c,会输出该数字对应的unicode字符
	var c4 int = 25554
	fmt.Printf("c4=%c\n",c4)

	// 6.字符类型是可以进行运算的，相当于一个整数，因为他都有对应的unicode码值
	var n1 = 10 + 'a'
	fmt.Println("n1=",n1)

	// 字符串的本质
	// 1.字符型存储到计算机中，需要将字符对应的码值（整数）找出来
	// 存储:字符----->对应码值------->二进制-------->存储
	// 读取:二进制------>码值------->字符------->读取
	// 2.字符和码值的对应关系是通过字符编码决定的（是规定好的）
	// 3.go语言的编码都统一成了UTF-8，非常的方便，很统一，再也没有编码乱码的困扰


	// 布尔类型
	// 1.布尔类型也叫bool类型，bool类型数据只允许取值true和false
	// 2.bool类型占一个字节
	// 3.bool类型适于逻辑运算，一般用于程序流程控制

	var b = false
	fmt.Println("b=",b)
	fmt.Println("b占用的空间=",unsafe.Sizeof(b))//1
}


















