

package main 

import (
	"fmt"
)


// 函数细节
// 1.函数的形参列表可以使多个，返回值列表也可以是多个
func getSumAndSub(n1 int, n2 int) (int, int) {
	sum := n1 + n2
	sub := n1 - n2
	return sum, sub
}

// 2.函数的命名遵循标识符命名规范，首字母不能是数字，首字母大写该函数可以被本包文件和其他包文件使用
func getSumAndSub2(n1 int, n2 int) (sum int, sub int) {
	sum = n1 + n2
	sub = n1 - n2
	return
}

// 3.形参列表和返回值列表的数据类型可以使值类型和引用类型
func test(n *int) {
	fmt.Printf("*n= %v n=%v\n",*n,n)
	*n = *n + 1 
}
// 4.函数中的变量是局部的，函数外不生效
// 5.基本数据类型和数组默认都是值传递额，即进行值拷贝。在函数内修改，不会影响到原来的值

func test2(n int) {
	n = n + 1
	fmt.Printf("n4=%d test2:%v\n",n,&n)
}
func main(){

	n1 := 10
	n2 := 8
	// 使用忽略值
	// _, sub := getSumAndSub(n1,n2)
	_, sub := getSumAndSub2(n1,n2)
	fmt.Println("sub=",sub)
	// 关于函数调用的说明
	// 1.在调用一个函数时，会给该函数分配一个新的空间，编译器会通过自身的处理让这个新的空间和其他的栈的空间区分开
	// 2.在每个函数对应的栈中，数据空间是独立的，不会混淆
	// 3.当一个函数调用完毕后，程序会销毁这个函数对应的栈空间

	n4 := 10
	n5 := &n4
	// 6.如果希望函数内的变量能修改函数外的变量（指的是默认以值传递的方式的数据类型），
	// 可以传入变量的地址&,函数内以指针的方式操作变量，从效果上看类似引用
	test(n5)
	fmt.Printf("n4=%d n5=%v\n",n4,n5)
	test2(n4)
	fmt.Println("n4=",n4)


	//为了简化数据类型定义，go支持自定义数据类型
	//基本语法：type 自定义数据类型名 数据类型 
	type myInt int 
	var num1 myInt
	var num2 int
	num1 = 40
	num2 = int(num1)//int和myInt是不同的类型
	fmt.Println("num1=",num1,"num2=",num2)

	type myFuncType func(int, int) int
	var myf myFuncType = getSum
	fmt.Printf("myf=%v\n",myf)

	r1 := myFun(myf,500,600)
	fmt.Println("r1=",r1)

	r2 := mySum(10,20,30,40)
	fmt.Println("s2=",r2)
}


func getSum(n1 int, n2 int) int {
	return n1 + n2
}


func myFun(myf func(int, int) int, num1 int, num2 int) int {
	return myf(num1,num2)
}
// 可变参数...
func mySum(n1 int, args...int) (r int) {
	r = n1
	for i := 0; i < len(args); i++ {
		r += args[i]
	}
	return
}



//包
//go 的每一个文件都是属于一个包的，也就是说 go 是以包的形式来管理文件和项目目录结构的
//包的作用
//1.区分相同名字的函数、变量等标识符
//2.当程序文件很多时,可以很好的管理项目
//3.控制函数、变量等访问范围，即作用域
//打包 package "包名"
//引包 import "包的路径"
//包细节说明
//1. 在给一个文件打包时，该包对应一个文件夹
//2. 文件的包名通常和文件所在的文件夹名一致，一般为小写字母
//3. 当一个文件要使用其它包函数或变量时，需要先引入对应的包
//4. 在 import 包时，路径从 $GOPATH 的 src 下开始，不用带 src , 编译器会自动从 src 下开始引入
//为了让其它包的文件，可以访问到本包的函数，则该函数名的首字母需要大写，类似其它语言 的 public ,这样才能跨包访问。
//5. 在访问其它包函数，变量时，其语法是 包名.函数名， 比如这里的 main.go 文件中
//6. 如果包名较长，Go 支持给包取别名， 注意细节:取别名后，原来的包名就不能使用了
//说明: 如果给包取了别名，则需要使用别名来访问该包的函数和变量。
//7. 在同一包下，不能有相同的函数名(也不能有相同的全局变量名)，否则报重复定义
//8. 如果你要编译成一个可执行程序文件，就需要将这个包声明为 main , 即 package main .这个就
// 是一个语法规范，如果你是写一个库 ，包名可以自定义

//函数值传递与引用传递
//我们在讲解函数注意事项和使用细节时，已经讲过值类型和引用类型了，这里我们再系统总结一 下，
//因为这是重难点，值类型参数默认就是值传递，而引用类型参数默认就是引用传递。
//其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的
//拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。
//值类型和引用类型
//值类型:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct
//引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型

//细节说明
//1.值类型默认是值传递，变量直接存储值，内存通常在栈中分配
//2.引用类型默认是引用传递，变量存储的是一个地址，变量存储的是一个地址，这个地址对应的空间才是真正存储数据的值
//内存通常在堆上分配，当没有任何变量引用这个数据的时候，会被GC回收
//3. 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&，
// 函数内以指针的方式操 作变量。从效果上看类似引用。

//变量作用域
//1.函数内部声明/定义的变量叫局部变量，作用域仅限于函数内部
//2.函数外部声明/定义的变量叫全局变量，作用域在整个包都有效，如果其首字母为大写，则作用 域在整个程序有效
//3.如果变量是在一个代码块，比如 for / if 中，那么这个变量的的作用域就在该代码块






